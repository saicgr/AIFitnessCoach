"""
‚ö†Ô∏è  DEPRECATED - DO NOT USE ‚ö†Ô∏è

This file has been REPLACED by the LangGraph onboarding agent.

OLD APPROACH (this file):
- Hardcoded question templates
- Manual question flow logic
- Separate from main agent system

NEW APPROACH (use instead):
- services/langgraph_onboarding_service.py
- services/langgraph_agents/onboarding/
- AI-generated questions (no templates!)
- Integrated with LangGraph agent system
- Handles vague inputs with clarifying questions

REASON FOR DEPRECATION:
User identified that hardcoded questions defeat the purpose of having an AI agent.
Questions felt templated, not AI-generated. Duplicate messages when user was vague.

This file is kept for reference only. Use LangGraphOnboardingService instead.
"""
from typing import Dict, Any, List, Optional
import json
from core.logger import get_logger
from services.openai_service import OpenAIService

logger = get_logger(__name__)


class OnboardingDataValidator:
    """Validates onboarding data for correctness and completeness."""

    REQUIRED_FIELDS = [
        'fitness_level',
        'goals',
        'equipment',
        'days_per_week',
        'selected_days',
        'workout_duration',
    ]

    def validate_partial(self, data: Dict[str, Any]) -> Dict[str, str]:
        """
        Validate partial data and return errors (if any).

        Args:
            data: Partial onboarding data

        Returns:
            Dict of field -> error message
        """
        errors = {}

        # Age validation
        if 'age' in data:
            try:
                age = int(data['age'])
                if age < 13 or age > 100:
                    errors['age'] = "Age must be between 13 and 100"
            except (ValueError, TypeError):
                errors['age'] = "Age must be a valid number"

        # Days consistency
        if 'selected_days' in data and 'days_per_week' in data:
            if len(data['selected_days']) != data['days_per_week']:
                errors['selected_days'] = f"Please select exactly {data['days_per_week']} days"

        # Height validation
        if 'heightCm' in data:
            try:
                height = float(data['heightCm'])
                if height < 100 or height > 250:
                    errors['heightCm'] = "Height must be between 100-250 cm"
            except (ValueError, TypeError):
                errors['heightCm'] = "Height must be a valid number"

        # Weight validation
        if 'weightKg' in data:
            try:
                weight = float(data['weightKg'])
                if weight < 30 or weight > 300:
                    errors['weightKg'] = "Weight must be between 30-300 kg"
            except (ValueError, TypeError):
                errors['weightKg'] = "Weight must be a valid number"

        # Goals validation
        if 'goals' in data:
            if not isinstance(data['goals'], list) or len(data['goals']) == 0:
                errors['goals'] = "Please select at least one goal"

        # Equipment validation
        if 'equipment' in data:
            if not isinstance(data['equipment'], list) or len(data['equipment']) == 0:
                errors['equipment'] = "Please select at least one equipment option"

        return errors

    def is_complete(self, data: Dict[str, Any]) -> tuple[bool, List[str]]:
        """
        Check if all required fields are present.

        Args:
            data: Onboarding data

        Returns:
            Tuple of (is_complete, list of missing fields)
        """
        missing = []
        for field in self.REQUIRED_FIELDS:
            if field not in data or not data[field]:
                missing.append(field)

        return (len(missing) == 0, missing)


class QuestionFlowEngine:
    """Determines next question based on collected data with smart context-aware skipping."""

    # Question sequence order (asked in this order unless skipped)
    QUESTION_SEQUENCE = [
        "name",
        "goals",
        "equipment",
        "days_per_week",
        "selected_days",
        "workout_duration",
        "fitness_level",
        "age",
        "gender",
        "heightCm",
        "weightKg",
        "target_weight_kg",  # Conditional
        "activity_level",     # Conditional
    ]

    def get_next_question(
        self,
        collected_data: Dict[str, Any],
        missing_fields: List[str]
    ) -> Dict[str, Any]:
        """
        Generate next question based on what's missing.

        Args:
            collected_data: Data collected so far
            missing_fields: List of fields still needed

        Returns:
            Dict with question details or completion marker
        """
        # Filter missing fields by sequence order
        ordered_missing = [
            field for field in self.QUESTION_SEQUENCE
            if field in missing_fields or field not in collected_data
        ]

        # Try each field in order
        for field in ordered_missing:
            # Check if we should skip this field based on context
            if self._should_skip_field(field, collected_data):
                continue

            # Generate question for this field
            return self._generate_question(field, collected_data)

        # No more questions - complete!
        return {"question": None, "type": "complete", "complete": True}

    def _should_skip_field(self, field: str, data: Dict[str, Any]) -> bool:
        """
        Determine if a field should be skipped based on collected data.

        Args:
            field: Field name to check
            data: Collected data so far

        Returns:
            True if field should be skipped
        """
        # Skip target_weight if no weight-related goals
        if field == "target_weight_kg":
            goals = data.get("goals", [])
            if not any(g in goals for g in ["Lose Weight", "Build Muscle", "General Health"]):
                return True

        # Skip equipment if already has it (inferred from previous answer)
        if field == "equipment":
            if "equipment" in data and data["equipment"]:
                return True

        # Skip activity_level if no TDEE-related goals
        if field == "activity_level":
            goals = data.get("goals", [])
            if not any(g in goals for g in ["Lose Weight", "Build Muscle"]):
                return True

        return False

    def _generate_question(self, field: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate the question text and options for a specific field.

        Args:
            field: Field name
            data: Collected data (for context-aware questions)

        Returns:
            Dict with question, type, and quick_replies
        """
        user_name = data.get("name", "")

        questions = {
            "name": {
                "question": "Hey! I'm your AI fitness coach ‚Äî here to help you get stronger, healthier, and stay consistent. Before we get started, what's your name?",
                "type": "text",
                "field_target": "name",
            },
            "goals": {
                "question": f"Nice to meet you, {user_name}! What are your main fitness goals? You can pick more than one." if user_name else "What are your main fitness goals? You can pick more than one.",
                "type": "multi_select",
                "field_target": "goals",
                "quick_replies": [
                    {"label": "Build muscle üí™", "value": "Build Muscle"},
                    {"label": "Lose weight üî•", "value": "Lose Weight"},
                    {"label": "Get stronger ‚ö°", "value": "Increase Strength"},
                    {"label": "Stay active üèÉ", "value": "Stay Active"},
                    {"label": "Improve endurance üèÉ‚Äç‚ôÇÔ∏è", "value": "Improve Endurance"},
                ],
            },
            "equipment": {
                "question": "Got it! What equipment do you have available? Select all that apply.",
                "type": "multi_select",
                "field_target": "equipment",
                "quick_replies": [
                    {"label": "Full gym üèãÔ∏è", "value": "Full Gym"},
                    {"label": "Dumbbells", "value": "Dumbbells"},
                    {"label": "Bodyweight only", "value": "Bodyweight Only"},
                    {"label": "Kettlebell", "value": "Kettlebell"},
                    {"label": "Resistance bands", "value": "Resistance Bands"},
                ],
            },
            "days_per_week": {
                "question": "Perfect! How many days per week can you realistically work out?",
                "type": "selection",
                "field_target": "days_per_week",
                "quick_replies": [
                    {"label": "3 days", "value": 3},
                    {"label": "4 days", "value": 4},
                    {"label": "5 days", "value": 5},
                    {"label": "6+ days", "value": 6},
                ],
            },
            "selected_days": {
                "question": f"Which {data.get('days_per_week', 3)} days work best for you?",
                "type": "day_picker",
                "field_target": "selected_days",
                "component": "day_picker",
            },
            "workout_duration": {
                "question": "How long do you want each workout to be?",
                "type": "selection",
                "field_target": "workout_duration",
                "quick_replies": [
                    {"label": "30 min", "value": 30},
                    {"label": "45 min", "value": 45},
                    {"label": "60 min", "value": 60},
                    {"label": "90 min", "value": 90},
                ],
            },
            "fitness_level": {
                "question": "What's your current fitness level?",
                "type": "selection",
                "field_target": "fitness_level",
                "quick_replies": [
                    {"label": "Beginner üå±", "value": "beginner"},
                    {"label": "Intermediate üí™", "value": "intermediate"},
                    {"label": "Advanced üî•", "value": "advanced"},
                ],
            },
            "age": {
                "question": "What's your age? (For accurate health metrics)",
                "type": "number",
                "field_target": "age",
                "placeholder": "e.g., 28",
            },
            "gender": {
                "question": "What's your gender? (For accurate calorie calculations)",
                "type": "selection",
                "field_target": "gender",
                "quick_replies": [
                    {"label": "Male", "value": "male"},
                    {"label": "Female", "value": "female"},
                    {"label": "Prefer not to say", "value": "prefer_not_to_say"},
                ],
            },
            "heightCm": {
                "question": "What's your height?",
                "type": "unit_input",
                "field_target": "heightCm",
                "component": "height_input",
                "placeholder": "e.g., 175 cm or 5'9\"",
            },
            "weightKg": {
                "question": "What's your current weight?",
                "type": "unit_input",
                "field_target": "weightKg",
                "component": "weight_input",
                "placeholder": "e.g., 70 kg or 154 lbs",
            },
            "target_weight_kg": {
                "question": "What's your target weight?",
                "type": "unit_input",
                "field_target": "target_weight_kg",
                "component": "weight_input",
                "placeholder": "e.g., 65 kg or 143 lbs",
            },
            "activity_level": {
                "question": "What's your daily activity level outside of workouts?",
                "type": "selection",
                "field_target": "activity_level",
                "quick_replies": [
                    {"label": "Sedentary (desk job)", "value": "sedentary"},
                    {"label": "Lightly active", "value": "lightly_active"},
                    {"label": "Moderately active", "value": "moderately_active"},
                    {"label": "Very active", "value": "very_active"},
                ],
            },
        }

        return questions.get(field, {
            "question": f"Please provide your {field}",
            "type": "text",
            "field_target": field,
        })


class OnboardingService:
    """Main orchestrator for conversational onboarding."""

    def __init__(self, openai_service: OpenAIService):
        self.openai = openai_service
        self.flow_engine = QuestionFlowEngine()
        self.validator = OnboardingDataValidator()

    async def process_user_message(
        self,
        message: str,
        current_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Process user message during onboarding conversation.

        This method:
        1. Extracts structured data from natural language
        2. Validates extracted data
        3. Merges with current data
        4. Determines next question

        Args:
            message: User's message
            current_data: Data collected so far

        Returns:
            Dict with extracted_data, next_question, is_complete, missing_fields
        """
        logger.info(f"üîç Processing onboarding message: {message[:50]}...")

        # Step 1: Extract data from user message
        extracted = await self._extract_data_from_message(message, current_data)
        logger.info(f"‚úÖ Extracted data: {extracted}")

        # Step 2: Validate extracted data
        errors = self.validator.validate_partial(extracted)
        if errors:
            logger.warning(f"‚ö†Ô∏è Validation errors: {errors}")
            # Return error question
            first_error = list(errors.values())[0]
            return {
                "extracted_data": {},
                "next_question": {
                    "question": f"Hmm, I couldn't quite get that. {first_error}",
                    "type": "text",
                },
                "is_complete": False,
                "missing_fields": [],
            }

        # Step 3: Merge with current data
        merged_data = {**current_data, **extracted}
        logger.info(f"üìä Merged data has {len(merged_data)} fields")

        # Step 4: Check if onboarding is complete
        is_complete, missing = self.validator.is_complete(merged_data)

        if is_complete:
            logger.info("üéØ Onboarding complete!")
            return {
                "extracted_data": extracted,
                "next_question": {
                    "question": "Perfect! I have everything I need. Let me generate your first workout...",
                    "type": "completion",
                    "complete": True,
                },
                "is_complete": True,
                "missing_fields": [],
            }

        # Step 5: Generate next question
        next_q = self.flow_engine.get_next_question(merged_data, missing)
        logger.info(f"‚ùì Next question: {next_q.get('field_target', 'unknown')}")

        return {
            "extracted_data": extracted,
            "next_question": next_q,
            "is_complete": False,
            "missing_fields": missing,
        }

    async def _extract_data_from_message(
        self,
        message: str,
        current_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Use OpenAI to extract structured onboarding data from natural language.

        Args:
            message: User's message
            current_data: Currently collected data

        Returns:
            Dict with extracted fields (only NEW information)
        """
        prompt = f"""Extract onboarding data from this user message.

User message: "{message}"

Current data already collected: {json.dumps(current_data, indent=2)}

Extract any NEW information. Return ONLY valid JSON:
{{
  "name": "User's name",  # If mentioned
  "goals": ["Build Muscle", "Lose Weight"],  # If mentioned
  "equipment": ["Dumbbells", "Kettlebell"],   # If mentioned
  "fitness_level": "beginner|intermediate|advanced",  # If mentioned
  "days_per_week": 3,  # If mentioned
  "workout_duration": 45,  # If mentioned (in minutes)
  "selected_days": [0, 2, 4],  # 0=Mon, 1=Tue, ... 6=Sun, If mentioned
  "preferred_time": "morning|afternoon|evening",  # If mentioned
  "age": 30,  # If mentioned
  "gender": "male|female|prefer_not_to_say",  # If mentioned
  "heightCm": 175,  # If mentioned (convert from ft/in to cm if needed)
  "weightKg": 70,  # If mentioned (convert lbs to kg if needed: lbs * 0.453592)
  "target_weight_kg": 65,  # If mentioned
  "active_injuries": ["shoulder pain"],  # If mentioned
  "health_conditions": [],  # If mentioned
  "activity_level": "sedentary|lightly_active|moderately_active|very_active",  # If mentioned
  "training_split": "full_body|upper_lower|push_pull_legs|body_part",  # Infer if possible
  "intensity_preference": "light|moderate|intense",  # Infer if possible
  "workout_experience": ["Weight Training", "Yoga"],  # If mentioned
  "workout_variety": "consistent|varied"  # Infer if possible
}}

CRITICAL RULES:
1. ONLY include fields where NEW information was found in the user message
2. DO NOT override or repeat existing data from current_data
3. Convert units: feet/inches ‚Üí cm (1 ft = 30.48 cm, 1 in = 2.54 cm), pounds ‚Üí kg (lbs * 0.453592)
4. Map colloquial terms: "build muscle" ‚Üí "Build Muscle", "lose fat" ‚Üí "Lose Weight", "get stronger" ‚Üí "Increase Strength"
5. Days: 0=Monday, 1=Tuesday, 2=Wednesday, 3=Thursday, 4=Friday, 5=Saturday, 6=Sunday
6. If user says "home workouts" or "at home" ‚Üí infer equipment: ["Bodyweight Only"] or if they mention specific equipment like "kettlebell at home" ‚Üí ["Kettlebell"]
7. If user says "3x per week" or "three times" ‚Üí days_per_week: 3
8. Return {{}} if no clear information found
9. For goals, use these exact strings: "Build Muscle", "Lose Weight", "Increase Strength", "Improve Endurance", "Stay Active", "Flexibility", "Athletic Performance", "General Health"
10. For equipment, use exact strings: "Bodyweight Only", "Dumbbells", "Barbell", "Resistance Bands", "Pull-up Bar", "Kettlebell", "Cable Machine", "Full Gym"
11. If user mentions specific exercises like "bench press", "squats", etc., infer goal as "Build Muscle" or "Increase Strength" and equipment as "Barbell" or "Full Gym"
12. If user just says an exact goal name like "Build Muscle" or "Lose Weight", extract that as their goal

Return ONLY the JSON object, nothing else."""

        try:
            response = await self.openai.client.chat.completions.create(
                model=self.openai.model,
                messages=[
                    {"role": "system", "content": "You are a data extraction system. Return ONLY valid JSON."},
                    {"role": "user", "content": prompt},
                ],
                temperature=0.1,  # Low temperature for consistent extraction
                max_tokens=500,
            )

            content = response.choices[0].message.content.strip()

            # Clean markdown if present
            if content.startswith("```json"):
                content = content[7:]
            elif content.startswith("```"):
                content = content[3:]
            if content.endswith("```"):
                content = content[:-3]

            extracted = json.loads(content.strip())
            logger.info(f"ü§ñ OpenAI extracted: {extracted}")
            return extracted

        except json.JSONDecodeError as e:
            logger.error(f"‚ùå Failed to parse OpenAI response: {e}")
            logger.error(f"Raw content: {content}")
            return {}
        except Exception as e:
            logger.error(f"‚ùå Extraction failed: {e}")
            return {}
